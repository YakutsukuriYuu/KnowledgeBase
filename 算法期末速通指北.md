## 01背包问题通解
https://www.luogu.com.cn/problem/P1048
https://acm.hdu.edu.cn/showproblem.php?pid=2602
```cpp
//装不下
dp[i][j] = dp[i-1][j]
//装得下
dp[i][j] = max(dp[i-1][j],dp[i-1][j-w_i] + v_i)
```

> 滚动数组
```cpp
dp[j] = max(dp[j],dp[j-w_i] + v_i)
//遍历倒序
```


```cpp
#include <iostream>

using namespace std;

const int MAXN=1e4;
int dp[MAXN][MAXN];

struct Node{
    int w;
    int v;
}node[MAXN];


void solve(int N,int W){
    for(int i=1;i<=N;i++){ //物品数
        for(int j=0;j<=W;j++){ //体积
            dp[i][j]=dp[i-1][j];
            if(j>=node[i].w){
                dp[i][j]=max(dp[i][j],dp[i-1][j-node[i].w]+node[i].v);
            }
        }
    }
}
int main(){
    int T;
    int M;
    cin>>T>>M;
    for(int i=1;i<=M;i++){
        cin>>node[i].w>>node[i].v;
    }
    solve(M,T);
    cout<<dp[M][T];
    return 0;
}
```


## 数字三角形
https://www.luogu.com.cn/problem/P1216
https://acm.hdu.edu.cn/showproblem.php?pid=2084
```cpp
#include <stdio.h>

#define MAXN 505
#define NEG_INF (-1000000000)

int a[MAXN][MAXN];
int dp[MAXN][MAXN];

int max(int x, int y) { return x > y ? x : y; }

int main() {
    int n;
    scanf("%d", &n);

    // 读入三角形：第 i 行有 i 个数
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            scanf("%d", &a[i][j]);
        }
    }

    // dp 初始化为很小的数，避免被错误取到
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            dp[i][j] = NEG_INF;
        }
    }

    // 初始条件
    dp[1][1] = a[1][1];

    // 状态转移
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            // 从上方两个位置转移： (i-1, j-1) 或 (i-1, j)
            dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + a[i][j];
        }
    }

    // 取最后一行最大值
    int ans = NEG_INF;
    for (int j = 1; j <= n; j++) {
        ans = max(ans, dp[n][j]);
    }

    printf("%d\n", ans);
    return 0;
}
```
## N皇后
https://www.luogu.com.cn/problem/P1219
```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int pos[15];            // pos[row] = col
bool colUsed[15];       // 某列是否已放
bool diag1Used[30];     // 主对角线：row + col
bool diag2Used[30];     // 副对角线：row - col + n
long long total = 0;

void dfs(int row) {
    if (row > n) {
        total++;
        if (total <= 3) {
            for (int i = 1; i <= n; i++) {
                if (i > 1) cout << ' ';
                cout << pos[i];
            }
            cout << '\n';
        }
        return;
    }

    // 按列从小到大枚举 -> 生成解的顺序就是字典序
    for (int c = 1; c <= n; c++) {
        if (colUsed[c]) continue;
        int d1 = row + c;
        int d2 = row - c + n;
        if (diag1Used[d1] || diag2Used[d2]) continue;

        pos[row] = c;
        colUsed[c] = diag1Used[d1] = diag2Used[d2] = true;

        dfs(row + 1);

        colUsed[c] = diag1Used[d1] = diag2Used[d2] = false;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    dfs(1);
    cout << total << '\n';
    return 0;
}
```
## 全排列
https://www.luogu.com.cn/problem/P1706


```cpp
#include <iostream>
using namespace std;
int num=0;
int data[]={1,2,3,4,5,6,7,8,9,10};
void perm(int* data,int begin,int end){
    if(begin==end){
        for (int i=0;i<=end;i++) {
            printf("%4d",data[i]);
            if(i==end) cout<<endl;
        }
        num++;
        return;
    }
    else{
        for(int i=begin;i<=end;i++){
            swap(data[begin],data[i]);
            perm(data,begin+1,end);
            swap(data[begin],data[i]);    
        }
    }
}
int main(){
    int n;
    cin>>n;
    perm(data,0,n-1);
    //cout<<num;
    return 0;
}



```
## 子集和
https://www.luogu.com.cn/problem/P1049
```cpp
#include <iostream>
using namespace std;

const int MAXN=1e3;
int arr[MAXN];
int choose[MAXN];
int V,n;
bool dfs(int* arr,int idx,int sum){
    if(sum==0) return 1;
    if(idx>n) return 0;
    if(sum<0) return 0;
    //选第一个数字
    choose[idx]=1;
    if(dfs(arr,idx+1,sum-arr[idx])) return 1;
    //不选第一个数
    choose[idx]=0;
    if(dfs(arr,idx+1,sum)) return 1;
    return 0;
}

int main(){


    int all=0;
    cin>>V>>n;
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }
    //cout<<dfs(arr,0,V);
    dfs(arr,0,V);
    for(int i=0;i<n;i++){
        if(choose[i]) cout<<arr[i]<<" ";
        //all+=arr[i];
    }
    //cout<<V-all;
    return 0;

}
```
# 二分
https://www.luogu.com.cn/problem/P2249

```cpp
#include <iostream>
using namespace std;
const int MAXN=1e6+9;
int arr[MAXN];

int find(int *arr,int l,int r,int x){
    if(l>r) return -1;
    int mid=l+(r-l)/2;
    if(arr[mid]>x) return find(arr,l,mid-1,x);
    else if(arr[mid]<x) return find(arr,mid+1,r,x);
    else {
        while(mid>1&&arr[mid-1]==x) --mid;
        return mid;
    }
}
int main(){
    int m,n,x;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>arr[i];
    }
    for(int i=0;i<m;i++){
        cin>>x;
        cout << find(arr,1,n,x) << (i == m ? '\n' : ' ');
    }
}
```
## 循环赛日程表（分治）
https://www.luogu.com.cn/problem/P1037
## 矩阵连乘
https://www.luogu.com.cn/problem/P1040
不考虑代码
## 会场安排
https://www.luogu.com.cn/problem/P1803
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Seg {
    int a, b;
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    vector<Seg> segs;
    segs.reserve(n);

    for (int i = 0; i < n; i++) {
        int a, b;
        cin >> a >> b;
        segs.push_back({a, b});
    }

    sort(segs.begin(), segs.end(), [](const Seg& x, const Seg& y) {
        if (x.b != y.b) return x.b < y.b;  // 结束时间小的优先
        return x.a < y.a;
    });

    int ans = 0;
    int last_end = -1; // 因为 ai >= 0，设成 -1 最安全
    for (const auto& s : segs) {
        if (s.a >= last_end) {
            ans++;
            last_end = s.b;
        }
    }

    cout << ans << "\n";
    return 0;
}
```